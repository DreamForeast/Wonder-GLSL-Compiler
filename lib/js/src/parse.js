// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List              = require("bs-platform/lib/js/list.js");
var Path              = require("path");
var Curry             = require("bs-platform/lib/js/curry.js");
var Caml_array        = require("bs-platform/lib/js/caml_array.js");
var Pervasives        = require("bs-platform/lib/js/pervasives.js");
var Js_primitive      = require("bs-platform/lib/js/js_primitive.js");
var Js_null_undefined = require("bs-platform/lib/js/js_null_undefined.js");

function _getFileName(path) {
  return Path.basename(path, Path.extname(path));
}

function _buildGlslContent(name, param) {
  var extname = Path.extname(name);
  if (extname === "") {
    var match = +name.startsWith("./");
    var match$1 = +name.startsWith("../");
    if (match !== 0) {
      return Pervasives.failwith("should import fileName, not filePath");
    } else if (match$1 !== 0) {
      return Pervasives.failwith("should import fileName, not filePath");
    } else {
      return "\n|> set(\"" + (String(name) + ("\", _buildChunk({|\n" + (String(param[0]) + ("\n|},{|\n" + (String(param[1]) + ("\n|},{|\n" + (String(param[2]) + ("\n|},{|\n" + (String(param[3]) + ("\n|},{|\n" + (String(param[4]) + ("\n|},{|\n" + (String(param[5]) + "\n|}))\n")))))))))))));
    }
  } else {
    return Pervasives.failwith("should import fileName without " + (String(extname) + ""));
  }
}

function _execRegex(regex, content, _startIndex, _recordList, noneFunc, someFunc) {
  while(true) {
    var recordList = _recordList;
    var startIndex = _startIndex;
    var match = regex.exec(content);
    if (match !== null) {
      _recordList = Curry._3(someFunc, match, startIndex, recordList);
      _startIndex = regex.lastIndex;
      continue ;
      
    } else {
      return Curry._2(noneFunc, startIndex, recordList);
    }
  };
}

function _getAllImportContent(fileName, segmentName, segmentContent, map) {
  var _get = function (fileNameList, segmentName, segmentContent, map) {
    var recordList = _execRegex((/#import\s+"(.+)"/g), segmentContent, 0, /* [] */0, (function (startIndex, recordList) {
            return /* :: */[
                    /* tuple */[
                      startIndex,
                      segmentContent.length,
                      /* None */0
                    ],
                    recordList
                  ];
          }), (function (result, startIndex, recordList) {
            return /* :: */[
                    /* tuple */[
                      startIndex,
                      result.index,
                      Js_primitive.null_undefined_to_opt(Js_null_undefined.bind(Caml_array.caml_array_get(result, 1), (function (importFileName) {
                                  var extname = Path.extname(importFileName);
                                  if (extname === "") {
                                    var match = +importFileName.startsWith("./");
                                    var match$1 = +importFileName.startsWith("../");
                                    if (match !== 0) {
                                      return Pervasives.failwith("should import fileName, not filePath");
                                    } else if (match$1 !== 0) {
                                      return Pervasives.failwith("should import fileName, not filePath");
                                    } else {
                                      var match$2 = map[importFileName];
                                      if (match$2 !== undefined) {
                                        var fileName = match$2["fileName"];
                                        var newFileNameList = /* :: */[
                                          fileName,
                                          fileNameList
                                        ];
                                        if (List.mem(fileName, fileNameList)) {
                                          var msg = List.fold_left((function (str, fileName) {
                                                    return str + (fileName + "=>");
                                                  }), "", List.rev(newFileNameList)).slice(0, -2);
                                          return Pervasives.failwith("not allow circular reference(the reference path is " + (String(msg) + ")"));
                                        } else {
                                          var match$3 = match$2[segmentName];
                                          if (match$3 !== undefined) {
                                            if ((/#import\s+"(.+)"/g).test(match$3)) {
                                              return _get(newFileNameList, segmentName, match$3, map);
                                            } else {
                                              return match$3;
                                            }
                                          } else {
                                            return Pervasives.failwith("segment:" + (String(segmentName) + (" should exist in " + (String(importFileName) + ".glsl"))));
                                          }
                                        }
                                      } else {
                                        return Pervasives.failwith("import glsl file:" + (String(importFileName) + " should exist"));
                                      }
                                    }
                                  } else {
                                    return Pervasives.failwith("should import fileName without " + (String(extname) + ""));
                                  }
                                })))
                    ],
                    recordList
                  ];
          }));
    return List.fold_left((function (content, param) {
                  var importSegmentContent = param[2];
                  return content + (segmentContent.slice(param[0], param[1]) + (
                            importSegmentContent ? importSegmentContent[0] : ""
                          ));
                }), "", List.rev(recordList));
  };
  return _get(/* :: */[
              fileName,
              /* [] */0
            ], segmentName, segmentContent, map);
}

function _convertListToMap(list) {
  return List.fold_left((function (map, param) {
                var match = param[6];
                var match$1 = param[5];
                var match$2 = param[4];
                var match$3 = param[3];
                var match$4 = param[2];
                var match$5 = param[1];
                var fileName = param[0];
                var segmentMap = { };
                segmentMap["fileName"] = fileName;
                segmentMap[match$5[0]] = match$5[1];
                segmentMap[match$4[0]] = match$4[1];
                segmentMap[match$3[0]] = match$3[1];
                segmentMap[match$2[0]] = match$2[1];
                segmentMap[match$1[0]] = match$1[1];
                segmentMap[match[0]] = match[1];
                map[fileName] = segmentMap;
                return map;
              }), { }, list);
}

function parseImport(list) {
  var map = _convertListToMap(list);
  return List.fold_left((function (content, param) {
                var match = param[6];
                var match$1 = param[5];
                var match$2 = param[4];
                var match$3 = param[3];
                var match$4 = param[2];
                var match$5 = param[1];
                var fileName = param[0];
                return content + _buildGlslContent(fileName, /* tuple */[
                            _getAllImportContent(fileName, match$5[0], match$5[1], map),
                            _getAllImportContent(fileName, match$4[0], match$4[1], map),
                            _getAllImportContent(fileName, match$3[0], match$3[1], map),
                            _getAllImportContent(fileName, match$2[0], match$2[1], map),
                            _getAllImportContent(fileName, match$1[0], match$1[1], map),
                            _getAllImportContent(fileName, match[0], match[1], map)
                          ]);
              }), "", list);
}

function parseSegment(actualGlslPath, content) {
  var endFlagRe = (/@end/g);
  var list = List.rev(List.fold_left((function (list, flag) {
              var index = content.indexOf(flag);
              var tmp;
              if (index !== -1) {
                var startIndex = index + flag.length | 0;
                var match = endFlagRe.exec(content);
                tmp = match !== null ? content.slice(startIndex, match.index).trim() : Pervasives.failwith("@end should match to segement flag");
              } else {
                tmp = "";
              }
              return /* :: */[
                      tmp,
                      list
                    ];
            }), /* [] */0, /* :: */[
            "@top",
            /* :: */[
              "@define",
              /* :: */[
                "@varDeclare",
                /* :: */[
                  "@funcDeclare",
                  /* :: */[
                    "@funcDefine",
                    /* :: */[
                      "@body",
                      /* [] */0
                    ]
                  ]
                ]
              ]
            ]
          ]));
  return /* tuple */[
          Path.basename(actualGlslPath, Path.extname(actualGlslPath)),
          /* tuple */[
            "top",
            List.nth(list, 0)
          ],
          /* tuple */[
            "define",
            List.nth(list, 1)
          ],
          /* tuple */[
            "varDeclare",
            List.nth(list, 2)
          ],
          /* tuple */[
            "funcDeclare",
            List.nth(list, 3)
          ],
          /* tuple */[
            "funcDefine",
            List.nth(list, 4)
          ],
          /* tuple */[
            "body",
            List.nth(list, 5)
          ]
        ];
}

exports._getFileName         = _getFileName;
exports._buildGlslContent    = _buildGlslContent;
exports._execRegex           = _execRegex;
exports._getAllImportContent = _getAllImportContent;
exports._convertListToMap    = _convertListToMap;
exports.parseImport          = parseImport;
exports.parseSegment         = parseSegment;
/* path Not a pure module */
